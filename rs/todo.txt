awkward comparison.  apples/oranges.  unfair.  wrong lens.  etc.
derive debug with :? is %A
[u8] is not on the heap.  it's like a primitive that is N bytes long.  it's a value type.
no each()
no exceptions.  use Result<>
no currying, no partial application
no significant whitespace
strings are utf8, no converting things
seriously miss full type inference
weird that it's safe to use unsigned
porting from fs is probably not a way to get good rust code
don't avoid mutability.  in rust, it's safe, and avoiding it is painful.
braces vim %
semicolons A ;, end-of-line comments
typing tetris
miss sprintf syntax
Read,Write,Seek traits so much better design than .NET streams
lots more for loops. but they're usually safer.  iter.  not numeric bounds.  but sometimes.
the stricter the compiler, the more I like it.
correlation of idiomatic and perf
optimizer makes a HUGE difference.
integer overflow checks not that expensive
type inference:  do I have the item or a reference to it?
ducking all concurrency issues for now.  perf impact.
vim mode SO much faster
rs is definitely more verbose and cluttered than fs
fs more productive
casts are never checked for overflow.  :-(
rust is unique.  f# is an ML on .NET.  feels kind of hybrid.
considering the CLR has better support for value types than its peers, fs doesn't use them as much as it could
try! vs SG_ERROR_CHECK
currently avoiding Rc,Arc,Cell,RefCell until I need them.
test harness is quite cool

too much usize.  use a more specific, smaller unsigned type.

why do usize and u64 require a cast?

cargo bench is very cool.
wish I could control the units (always ns) are get them to display with commas or something

move everything into the same module.  myCursor should not be public.

concurrency
list of cursors
want to be able to write multiple segments simultaneously.
but access to the header and to housekeeping structures must be safe.

streaming iterator model for ICursor?

database trait can go away

segment id, would be nice to make it u64

same for pgnum but then storage is wasteful,
want to store as a varint, but then space in the page calculations are
more complicated.

varint in a separate crate?

better way to copy a slice?

does IPages need Result?

ICursor definitely needs Result

reduce malloc

expect instead of unwrap

prefixlen > 255

looks like kvp stuff should probably stay boxed.  both the key and value
always need to be held longer than one iteration, usually until the
end of the leaf, and one key for each leaf gets held longer than that.
which means if the caller provided this as a reference instead of a box,
we would have to make a copy no matter what, and if the caller had to
construct a box anyway, we would have done it twice.

multicursor.Next looks slow.  lots of key compares.

maybe myOverflowReadStream shouldn't be returned as a trait object.


