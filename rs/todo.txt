
awkward comparison.  apples/oranges.  unfair.  wrong lens.  etc.
derive debug with :? is %A
[u8] is not on the heap.  it's like a primitive that is N bytes long.  it's a value type.
no each()
no exceptions.  use Result<>
no currying, no partial application
no significant whitespace
strings are utf8, no converting things
seriously miss full type inference
weird that it's safe to use unsigned
porting from fs is probably not a way to get good rust code
don't avoid mutability.  in rust, it's safe, and avoiding it is painful.
braces vim %
semicolons A ;, end-of-line comments
typing tetris
miss sprintf syntax
Read,Write,Seek traits so much better design than .NET streams
lots more for loops. but they're usually safer.  iter.  not numeric bounds.  but sometimes.
the stricter the compiler, the more I like it.
correlation of idiomatic and perf
optimizer makes a HUGE difference.
integer overflow checks not that expensive
type inference:  do I have the item or a reference to it?
vim mode SO much faster
rs is definitely more verbose and cluttered than fs
fs more productive
casts are never checked for overflow.  :-(
rust is unique.  f# is an ML on .NET.  feels kind of hybrid.
considering the CLR has better support for value types than its peers, fs doesn't use them as much as it could
try! vs SG_ERROR_CHECK
currently avoiding Rc,Arc,Cell,RefCell until I need them.
test harness is quite cool
I like integers without suffixes being more flexible

really cool using valgrind.  
and really cool that valgrind shouldn't be as useful.

too much usize.  use a more specific, smaller unsigned type.

why do usize and u64 require a cast?

cargo bench is very cool.
wish I could control the units (always ns) are get them to display with commas or something

streaming iterator model for ICursor?

same for pgnum but then storage is wasteful,
want to store as a varint, but then space in the page calculations are
more complicated.

varint in a separate crate?

graveyard

reduce malloc

prefixlen > 255

looks like kvp stuff should probably stay boxed.  both the key and value
always need to be held longer than one iteration, usually until the
end of the leaf, and one key for each leaf gets held longer than that.
which means if the caller provided this as a reference instead of a box,
we would have to make a copy no matter what, and if the caller had to
construct a box anyway, we would have done it twice.

maybe myOverflowReadStream shouldn't be returned as a trait object.

a little worried about the KeyCompare always being built in to Seek.
what about cases that don't use it?

tempted to limit key size.  no overflows for keys.  key is limited by
the page size (minus overhead).  if you need a bigger key, then use a
bigger page size.

currently no tests for an overflowed key?

currently using trait objects Seek+Write for writing to the db.  the overhead
of dynamic dispatch is negligible compared to the IO, right?

annoying that I can't have a mut reference to one element of an array
while holding any reference to any other element of the array.

