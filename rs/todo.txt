
msbuild
warning vs error on match incomplete
awkward comparison.  apples/oranges.  unfair.  wrong lens.  etc.
derive debug with :? is %A
[u8] is not on the heap.  it's like a primitive that is N bytes long.  it's a value type.
no each(), which is fs is iter(), but in rs that is something else.
no exceptions.  use Result<>
no currying, no partial application
no significant whitespace
tabs allowed.  :-(
strings are utf8, no converting things
seriously miss full type inference
weird that it's safe to use unsigned
porting from fs is probably not a way to get good rust code
don't avoid mutability.  in rust, it's safe, and avoiding it is painful.
braces vim %
semicolons vim A ;, end-of-line comments
typing tetris
miss sprintf syntax
Read,Write,Seek traits so much better design than .NET streams
lots more for loops. but they're usually safer.  iter.  not numeric bounds.  but sometimes.
the stricter the compiler, the more I like it.
correlation of idiomatic and perf
optimizer makes a HUGE difference.
integer overflow checks not that expensive
type inference:  do I have the item or a reference to it?
vim mode SO much faster.  except sometimes it gets stuck.
rs is definitely more verbose and cluttered than fs
fs more productive, more pleasant
casts are never checked for overflow.  :-(
rust is unique, and it never feels like it inherits dorkiness from the platform it is built on.
f# is an ML on .NET.  feels kind of hybrid sometimes.  null but not.
considering the CLR has better support for value types than its peers, fs doesn't use them as much as it could
try! vs SG_ERROR_CHECK
currently avoiding Rc,Arc,Cell,RefCell until I need them.
test harness is quite cool
I like integers without suffixes being more flexible

really cool using valgrind.  
and really cool that valgrind shouldn't be as useful.

too much usize?  use a more specific, smaller unsigned type.

why do usize and u64 require a cast?  usize is not an alias.

cargo bench is very cool.
wish I could control the units (always ns) or get them to display with commas or something

make pgnum a u64?
same for pgnum but then storage is wasteful,
want to store as a varint, but then space in the page calculations are
more complicated.

varint in a separate crate?  but optimizer can't cross crate boundaries.

core feature:  graveyard

reduce malloc

prefixlen > 255

looks like kvp stuff should probably stay boxed.  both the key and value
always need to be held longer than one iteration, usually until the
end of the leaf, and one key for each leaf gets held longer than that.
which means if the caller provided this as a reference instead of a box,
we would have to make a copy no matter what, and if the caller had to
construct a box anyway, we would have done it twice.

a little worried about the KeyCompare always being built in to Seek.
what about cases that don't use it?

tempted to limit key size.  no overflows for keys.  key is limited by
the page size (minus overhead).  if you need a bigger key, then use a
bigger page size.

currently no tests for an overflowed key?

currently using trait objects Seek+Write for writing to the db.  the overhead
of dynamic dispatch is negligible compared to the IO, right?

annoying that I can't have a mut reference to one element of an array
while holding any reference to any other element of the array.

in theory, rust should be able to infer types for functions and their
arguments, plus lifetimes.  but this would require far more analysis,
so currently, the programmer is required to make these things explicit
at the function boundaries.  i wonder if this kind of analysis will
be possible later.

I wonder if Key() and Value() should just go away, replacing them
with KeyRef() and ValueRef().  The caller is always free to do the
allocation if they want.

multiple passes, number of errors jumps up and down

what if db goes out of scope with pending segments?

problem:
    assert!(f().is_ok());

let's not panic (int underflow) when we try to write a segment
but the source iterator provides no pairs

https://github.com/zslayton/lifeguard

stray, block list, etc

automerge?  in a thread?

cleanup bcmp and friends

vbuf reuse write leaves

review lock ordering


