
need a more efficient way to add a zero-length value

keys for documents:
    d/collectionID/rid -> json

keys for index entries:
    i/collectionID/path/value/rid -> nothing

    i vs d, single byte
    
    collID.  string?

    path is a series of zero-terminated utf8 strings

    special delimiter before the value

    value is a type byte + encoding for that type

    delimiter after the value

    then rid

how to make sure value cannot be interpreted as part of the
path

is an empty string valid as part of the path?

perhaps each path element needs a prefix to show whether it is
a string key or an array index?

seek in myOverflowReadStream

still lots of automerge issues

opencursor issues, info for optimistic merge

more test cases

hooks for page level encryption plugins

need to actually design the file header
    checksums for data integrity
    format version number

do we need IDatabase if there is only one implementation
of it?  same for IWriteLock.

--

range splitting

fractional cascading

range deletes

suffix deletes

bloom filters?

try to improve the performance of multicursor

lz4 stream

experiment with inline for certain functions

consider nessos streams instead of seq<kvp> ?

need something to make sure that only one Database object
exists for a given file

do we have a test that chains multicursors with other multicursors?
do we need one?  that should actually never happen in normal use.

#if integrity_checks

look at reducing memory allocations in writeLeaves.  (done?)

write a test that verifies that BTreeSegment.Create
never seeks if it has no boundary.  (but overflows break
this now).  need a stream
that overrides seek and throws.  this test preserves
the ability to write a btree into almost any kind of
stream.  common use case remains writing with an
involved page manager.

test multicursor with the same cursor twice?

test multicursor with two identical subs?

still concerned about how much we are copying byte[] for keys

what are the embedded pointers in the runs in SQLite4 LSM?

now we can chain a
zlib stream and compress as it goes in.

create shorter synthetic keys in the parent nodes?


