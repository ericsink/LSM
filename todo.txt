
shorter keys in the parent nodes?

prefix key compression?

the test suite is using the old memory_segment api

need C# versions of the other Create overloads?

ICursor ToSeq should probably not be extension methods

#if integrity_checks

combine stream and its page manager into an object?  
called IDest?

yeah, ICursor is really close to seq anyway.  next would return a bool.
current would return the tuple pair.  first() would just be the
initial call to movenext.  last(), prev(), seek() aren't there.

comment on create that seq must be sorted.

OpenCursorfor idictionary -- sort the keys and then
create a memory btree?  or copy the dictionary (so the
values don't change) and just keep them both?

it would be nice to have an in-memory data structure
that has the functionality needed for an icursor.
sorted keys, with the ability to specify the comparer.

dictionary won't work because it's not sorted.

map won't work because it only sorts the way it wants.

sorteddictionary is (1) not immutable and (2) not WinRT
bcl.

can we have a readonly byte array?

wrap a ReadOnlyDictionary the way we wrap a dictionary now?
problem is that ROD is designed for cases where you want to
pass it to somebody else knowing that they won't modify
it.  what we care about is receiving it and knowing that
the originator will not modify it.  not quite the same.

ImmutableSortedDictionary from System.Collections.Immutable.
This one could wrap as an ICursor without problems I think.

look at ExtCore.HashMap

need a btree.create that just takes a dest stream
and doesn't care about pagemanager?  or one that just
writes to a memory stream?

look at reducing memory allocations in writeLeaves

write a test that verifies that BTreeSegment.Create
never seeks if it has no boundary.  need a stream
that overrides seek and throws.  this test preserves
the ability to write a btree into almost any kind of
stream.  common use case remains writing with an
involved page manager.

--------

test multicursor with the same cursor twice?

test multicursor with two identical subs?

--------

fsharp stuff:

way too many mutables in the fs code

way too many if-then places in the fs code

way too many for/while loops in the fs code

--------

checksums for data integrity

still concerned about how much we are copying byte[] for keys

what are the embedded pointers in the runs in SQLite4 LSM?

tombstones shouldn't need a length field as well.
but the absence would mess up the space_needed calcs.
and if the length is always zero, it's just a byte.

fix the realloc of leafKeys in the cs code as well?  or is
the cs code just becoming part of the fs version's test suite?

--------

once "on disk", a segment is immutable.  reads only.
only the first (in-memory) segment needs to support writes.

maybe the whole thing should implement IDictionary<byte[],byte[]> ?

--------

is there any chance we should be using things like Stream.ReadAsync?
async-ness would propagate all the way up...  or should the decision
to use async/threads be up to the caller, like the threads test I've
got?

--------

can we write an overflow without knowing its length in
advance?  that would be handy.  maybe we could chain a
zlib stream and compress as it goes in.  but how do we
set the skip field?  we pretty much can't.  I suppose we
could just write the whole thing and then go back and
write the skip field.

we can't do calculations on whether a value will fit if
we don't know its length.  such a value automatically
becomes an overflow.  after we write the overflow, then
we know its length.


